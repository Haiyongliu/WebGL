<!--DOCTYPE html-->
<html>
    <head>
        <meta chartset="utf-8">
        <title>TextureLoader Demo</title>
        <style>
            body { margin: 0;}
            canvas { width:100%;height: 100%; }
        </style>
    </head>

    <body>
        
    </body>
    <script src="./js/three.js"></script>
    <script >
        var scene;
        var camera;
        var renderer;
        var model;

        var radius = Math.PI/2;

        var TYPE_ROTATION = 0;
        var TYPE_INSIGHT = 1;
        var TYPE_POSITION = 2;
        var renderType = TYPE_POSITION;

        var cubeCamera;
        var material;
        var cubeMesh;

        initEnv();
        createModel();
        attachCanvas();
        putModel();
        registEventListener();

        function registEventListener(){
            document.body.addEventListener("click",function(){
                animate();
            });
            window.addEventListener('resize' ,onWindowResize ,false);
        }

        function initEnv(){
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45 ,window.innerWidth/window.innerHeight ,0.01 ,100000);
            camera.position.set(1000 ,0 ,1000);
            camera.lookAt(0,0,0);
            renderer = new THREE.WebGLRenderer( {antiailias:true} );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize(window.innerWidth ,window.innerHeight);
            
            cubeCamera = new THREE.CubeCamera( 1, 1024, 1024);
        }

        function createModel(){
            var loader = new THREE.TextureLoader();
            var options = {
					generateMipmaps: true,
					minFilter: THREE.LinearMipmapLinearFilter,
					magFilter: THREE.LinearFilter
				};
            loader.load('./resource/scene_bg_c.jpeg' , function ( texture) {
                texture.mapping = THREE.UVMapping;
                scene.background = new THREE.WebGLRenderTargetCube(4096,4096,options).fromEquirectangularTexture(renderer ,texture);
                cubeCamera.renderTarget.texture.generateMipmaps = true;
                cubeCamera.renderTarget.texture.minFilter = THREE.LinearMipmapLinearFilter;
                cubeCamera.update( renderer, scene );
                render();
            });

            // Shape
            var boxGeometry = new THREE.BoxGeometry(512,512,512);
            /**
            * 这里有三种不同的材质可以Demo
            */
            // Material
            // material =  new THREE.MeshPhongMaterial( { color: 0x121436, emissive: 0x754054, side: THREE.DoubleSide, flatShading: true } );
            // material = new THREE.MeshBasicMaterial( {
			// 		envMap: cubeCamera.renderTarget.texture
            //     } );
            material = new THREE.MeshPhysicalMaterial( {
							color: 0xffffff, envMap: cubeCamera.renderTarget.texture, metalness: 3, roughness: 0, transparency: 1, transparent: true, name: 'clear'
						} );
            cubeMesh = new THREE.Mesh(boxGeometry,material);
        }

        function attachCanvas(){
            document.body.appendChild(renderer.domElement);
        }

        function putModel(){
            //async load by TextureLoader
            scene.add( cubeMesh );
            scene.add( cubeCamera );
        }

        function render(){
            /**
            * 该模型中（WebGLRenderTargetCube），把图片转换成方块，相继无论如何位于方块中心点位置，
            * 所以，camera的position值最终都会按照三角函数将（x,y,z）转换成rotation的角度，
            *
            * 特别注意:1. 函数#renderPosition lookAt会执行转换成rotation的动作，如果不调用，则不会起到任何作用。
            *         2. 函数#renderRotation 和lookAt冲突，所以只能使用其一。
            */
            switch (renderType){
                case TYPE_ROTATION:
                    configRotation();
                    break;
                case TYPE_POSITION:
                    configPosition();
                    break;
                case TYPE_INSIGHT:
                    configInsight();
                    break;
            }
            render();
        }

        function render(){
            cubeMesh.rotation.x += 0.01;
            cubeMesh.rotation.y += 0.01;
            cubeMesh.rotation.z += 0.01;
            renderer.render(scene ,camera);
        }

        function configInsight(){
            radius += 0.01;
            camera.lookAt( 10000 * Math.sin(radius) ,10000 * Math.cos(radius),0 );
        }

        function configPosition(){
            radius += 0.01;
            camera.position.x = 1000;
            camera.position.y = 1000 * Math.cos(radius);
            camera.position.z = 1000;
            camera.lookAt( scene.position );
        }

        function configRotation(){
            // camera.rotation.x += 0.005;
            //水平旋转
            camera.rotation.y += 0.005;
            // camera.rotation.z += 0.005;
        }

        function animate(){
            render();
            requestAnimationFrame(animate);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );
            render();
        }
    </script>
</html>